import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { CoursModule } from '../src/cours/cours.module';
import { CoursService } from '../src/cours/cours.service';
import { PrismaService } from '../src/prisma/prisma.service';
import { JwtAuthGuard } from '../src/common/guards/jwt-auth.guard';
import { RolesGuard } from '../src/common/guards/roles.guard';
import { CsrfGuard } from '../src/common/guards/csrf.guard';
import { ValidationPipe } from '@nestjs/common';

describe('Communication E2E - Simulation Noah fait le Cours de Communication', () => {
  let app: INestApplication;
  let coursService: CoursService;
  
  const childId = 3;
  const childName = 'Noah';

  // Storage pour simuler la persistance
  let progressStorage: any = {
    childId: childId,
    matiere: 'communication',
    currentStep: 'introduction',
    progressPercent: 0,
    data: {},
    completedAt: null,
  };

  // Mock simple pour PrismaService
  const mockPrisma = {
    child: {
      findUnique: jest.fn().mockResolvedValue({
        id: childId,
        firstName: childName,
        lastName: 'Moreau',
      }),
    },
  };

  // Mock du CoursService avec persistance simul√©e
  const mockCoursService = {
    getMatieres: jest.fn().mockResolvedValue([
      { id: 'francais', title: 'Fran√ßais', description: 'Lecture, √©criture et expression', available: true },
      { id: 'math', title: 'Math√©matiques', description: 'Nombres, calculs et logique', available: true },
      { id: 'communication', title: 'Communication', description: 'Pictogrammes et expression', available: true },
    ]),
    
    getMatiere: jest.fn().mockImplementation((matiereId, childId) => {
      if (matiereId === 'communication') {
        return Promise.resolve({
          id: 'communication',
          title: 'Communication',
          description: 'Pictogrammes et expression',
          estimatedDuration: 10,
          steps: ['introduction', 'reconnaissance', 'association', 'expression', 'interaction', 'synthese'],
        });
      }
      return Promise.resolve(null);
    }),
    
    getProgress: jest.fn().mockImplementation(() => {
      return Promise.resolve({ ...progressStorage });
    }),
    
    saveProgress: jest.fn().mockImplementation((data) => {
      progressStorage = { ...progressStorage, ...data };
      return Promise.resolve(progressStorage);
    }),
    
    updateProgress: jest.fn().mockImplementation((childId, matiere, data) => {
      progressStorage = { ...progressStorage, ...data };
      return Promise.resolve(progressStorage);
    }),
    
    completeCours: jest.fn().mockImplementation((childId, matiere) => {
      progressStorage = {
        ...progressStorage,
        childId,
        matiere,
        currentStep: 'synthese',
        progressPercent: 100,
        completedAt: new Date(),
      };
      return Promise.resolve(progressStorage);
    }),
    
    getChildStats: jest.fn().mockResolvedValue({
      totalCours: 3,
      coursCompleted: 1,
      averageProgress: 100,
      lastActivity: new Date(),
    }),
  };

  // Mock simple pour les Guards (pas d'auth)
  const mockAuthGuard = {
    canActivate: jest.fn().mockReturnValue(true),
  };

  const mockRolesGuard = {
    canActivate: jest.fn().mockReturnValue(true),
  };

  const mockCsrfGuard = {
    canActivate: jest.fn().mockReturnValue(true),
  };

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [CoursModule],
    })
      .overrideProvider(PrismaService)
      .useValue(mockPrisma)
      .overrideProvider(CoursService)
      .useValue(mockCoursService)
      .overrideGuard(JwtAuthGuard)
      .useValue(mockAuthGuard)
      .overrideGuard(RolesGuard)
      .useValue(mockRolesGuard)
      .overrideGuard(CsrfGuard)
      .useValue(mockCsrfGuard)
      .compile();

    app = moduleFixture.createNestApplication();
    
    app.useGlobalPipes(new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: false,
      transform: true,
      disableErrorMessages: false,
      validateCustomDecorators: true,
    }));
    
    coursService = moduleFixture.get<CoursService>(CoursService);
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('üí¨ Noah fait le Cours de Communication - Les Pictogrammes', () => {
    let currentProgress: any = null;

    it('üéØ √âtape 1: Noah d√©couvre la communication', async () => {
      console.log(`\nüßí ${childName} se connecte et regarde les mati√®res disponibles...`);
      
      const response = await request(app.getHttpServer())
        .get(`/cours/child/${childId}/matieres`)
        .expect(200);

      expect(response.body).toHaveLength(3);
      
      const communication = response.body.find((m: any) => m.id === 'communication');
      expect(communication).toMatchObject({
        id: 'communication',
        title: 'Communication',
        description: 'Pictogrammes et expression',
        available: true,
      });

      console.log('‚úÖ Noah voit ses 3 mati√®res disponibles');
      console.log(`üéØ Il choisit la Communication : "${communication.description}"`);
    });

    it('üí¨ √âtape 2: Noah ouvre le cours de communication', async () => {
      console.log(`\nüí¨ ${childName} ouvre le cours de Communication...`);
      
      const response = await request(app.getHttpServer())
        .get(`/cours/child/${childId}/matiere/communication`)
        .expect(200);

      expect(response.body).toMatchObject({
        id: 'communication',
        title: 'Communication',
        description: 'Pictogrammes et expression',
        estimatedDuration: 10,
        steps: ['introduction', 'reconnaissance', 'association', 'expression', 'interaction', 'synthese'],
      });

      console.log(`üìã Cours: "${response.body.title}" - ${response.body.estimatedDuration} minutes`);
      console.log(`üñºÔ∏è Sujet: Pictogrammes pour communiquer`);
      console.log(`üî¢ ${response.body.steps.length} √©tapes √† suivre`);
    });

    it('üñºÔ∏è √âtape 3: Noah d√©couvre les pictogrammes', async () => {
      console.log(`\nüñºÔ∏è ${childName} d√©couvre les pictogrammes...`);
      
      // V√©rifier la progression initiale
      const initialResponse = await request(app.getHttpServer())
        .get(`/cours/child/${childId}/progress/communication`)
        .expect(200);

      expect(initialResponse.body).toMatchObject({
        childId: childId,
        matiere: 'communication',
        currentStep: 'introduction',
        progressPercent: 0,
      });

      // Noah progresse dans l'introduction
      const progressData = {
        childId: childId,
        matiere: 'communication',
        currentStep: 'introduction',
        progressPercent: 17, // 1/6 √©tapes
        data: { 
          conceptUnderstood: true,
          visualExamples: ['üè† = maison', 'üçé = pomme', 'üòä = content'],
          purpose: 'Exprimer ses besoins et √©motions',
          engagement: 'tr√®s √©lev√©'
        },
      };

      const saveResponse = await request(app.getHttpServer())
        .post('/cours/progress')
        .send(progressData)
        .expect(201);

      currentProgress = saveResponse.body;
      
      console.log('üñºÔ∏è Introduction termin√©e !');
      console.log('üìö Exemples d√©couverts:');
      console.log('   üè† = maison');
      console.log('   üçé = pomme');
      console.log('   üòä = content');
      console.log('üí° Objectif: Exprimer ses besoins et √©motions');
      console.log(`üìä Progression: ${currentProgress.progressPercent}%`);
    });

    it('üëÅÔ∏è √âtape 4: Noah apprend √† reconna√Ætre les pictogrammes', async () => {
      console.log(`\nüëÅÔ∏è ${childName} apprend √† reconna√Ætre les pictogrammes...`);
      
      const progressData = {
        childId: childId,
        matiere: 'communication',
        currentStep: 'reconnaissance',
        progressPercent: 33, // 2/6 √©tapes
        data: { 
          categories: {
            'besoins': ['üöΩ = toilettes', 'üçΩÔ∏è = manger', 'üí§ = dormir'],
            '√©motions': ['üòä = content', 'üò¢ = triste', 'üò° = en col√®re'],
            'activit√©s': ['‚öΩ = jouer', 'üìö = lire', 'üéµ = musique']
          },
          recognition: {
            'üöΩ': 'toilettes',
            'üòä': 'content',
            '‚öΩ': 'jouer'
          },
          score: 9,
          totalQuestions: 9
        },
      };

      const response = await request(app.getHttpServer())
        .post('/cours/progress')
        .send(progressData)
        .expect(201);

      currentProgress = response.body;
      
      console.log('üëÅÔ∏è Reconnaissance ma√Ætris√©e !');
      console.log('üìÇ Cat√©gories apprises:');
      console.log('   üéØ Besoins: üöΩ üçΩÔ∏è üí§');
      console.log('   üòä √âmotions: üòä üò¢ üò°');
      console.log('   üéÆ Activit√©s: ‚öΩ üìö üéµ');
      console.log(`üèÜ Score: ${progressData.data.score}/${progressData.data.totalQuestions} - Parfait !`);
      console.log(`üìä Progression: ${currentProgress.progressPercent}%`);
    });

    it('üîó √âtape 5: Noah associe pictogrammes et situations', async () => {
      console.log(`\nüîó ${childName} associe pictogrammes et situations...`);
      
      const progressData = {
        childId: childId,
        matiere: 'communication',
        currentStep: 'association',
        progressPercent: 50, // 3/6 √©tapes
        data: { 
          associations: [
            { situation: 'Il est midi', pictogramme: 'üçΩÔ∏è', correct: true },
            { situation: 'Noah est fatigu√©', pictogramme: 'üí§', correct: true },
            { situation: 'Il veut jouer dehors', pictogramme: '‚öΩ', correct: true },
            { situation: 'Noah est heureux', pictogramme: 'üòä', correct: true }
          ],
          contextualUnderstanding: 'excellent',
          flexibility: 'd√©velopp√©e'
        },
      };

      const response = await request(app.getHttpServer())
        .post('/cours/progress')
        .send(progressData)
        .expect(201);

      currentProgress = response.body;
      
      console.log('üîó Associations r√©ussies !');
      console.log('‚úÖ "Il est midi" ‚Üí üçΩÔ∏è');
      console.log('‚úÖ "Noah est fatigu√©" ‚Üí üí§');
      console.log('‚úÖ "Il veut jouer dehors" ‚Üí ‚öΩ');
      console.log('‚úÖ "Noah est heureux" ‚Üí üòä');
      console.log('üéØ Compr√©hension contextuelle: Excellente !');
      console.log(`üìä Progression: ${currentProgress.progressPercent}%`);
    });

    it('üó£Ô∏è √âtape 6: Noah s\'exprime avec les pictogrammes', async () => {
      console.log(`\nüó£Ô∏è ${childName} s'exprime avec les pictogrammes...`);
      
      const progressData = {
        childId: childId,
        matiere: 'communication',
        currentStep: 'expression',
        progressPercent: 67, // 4/6 √©tapes
        data: { 
          expressions: [
            { phrase: 'Noah veut üçé et ü•õ', meaning: 'Noah veut une pomme et du lait' },
            { phrase: 'Noah est üòä avec ‚öΩ', meaning: 'Noah est content de jouer au ballon' },
            { phrase: 'Noah üí§ apr√®s üçΩÔ∏è', meaning: 'Noah dort apr√®s manger' }
          ],
          creativity: '√©mergente',
          spontaneity: '√©lev√©e',
          confidence: 'croissante'
        },
      };

      const response = await request(app.getHttpServer())
        .post('/cours/progress')
        .send(progressData)
        .expect(201);

      currentProgress = response.body;
      
      console.log('üó£Ô∏è Expression d√©velopp√©e !');
      console.log('üí¨ Phrases cr√©√©es par Noah:');
      progressData.data.expressions.forEach((expr: any, index: number) => {
        console.log(`   ${index + 1}. ${expr.phrase} = "${expr.meaning}"`);
      });
      console.log('üåü Cr√©ativit√© √©mergente et spontan√©it√© √©lev√©e !');
      console.log(`üìä Progression: ${currentProgress.progressPercent}%`);
    });

    it('ü§ù √âtape 7: Noah interagit avec les autres', async () => {
      console.log(`\nü§ù ${childName} interagit avec les autres...`);
      
      const progressData = {
        childId: childId,
        matiere: 'communication',
        currentStep: 'interaction',
        progressPercent: 83, // 5/6 √©tapes
        data: { 
          interactions: [
            { 
              context: 'R√©cr√©ation avec un ami',
              request: '‚öΩ ensemble ?',
              response: 'üòä oui !',
              success: true
            },
            { 
              context: 'Demande √† l\'√©ducateur',
              request: 'üöΩ s\'il te pla√Æt',
              response: 'Accord√©',
              success: true
            },
            { 
              context: 'Expression d\'un besoin',
              request: 'üçΩÔ∏è j\'ai faim',
              response: 'Compris',
              success: true
            }
          ],
          socialSkills: 'd√©velopp√©es',
          autonomy: 'croissante'
        },
      };

      const response = await request(app.getHttpServer())
        .post('/cours/progress')
        .send(progressData)
        .expect(201);

      currentProgress = response.body;
      
      console.log('ü§ù Interactions r√©ussies !');
      console.log('üë´ R√©cr√©ation: "‚öΩ ensemble ?" ‚Üí üòä oui !');
      console.log('üë®‚Äçüè´ √âducateur: "üöΩ s\'il te pla√Æt" ‚Üí Accord√©');
      console.log('üçΩÔ∏è Besoin: "üçΩÔ∏è j\'ai faim" ‚Üí Compris');
      console.log('üåü Comp√©tences sociales d√©velopp√©es !');
      console.log('üöÄ Autonomie croissante !');
      console.log(`üìä Progression: ${currentProgress.progressPercent}%`);
    });

    it('üéâ √âtape 8: Noah termine le cours avec succ√®s', async () => {
      console.log(`\nüéâ ${childName} termine le cours de Communication !`);
      
      // Completion du cours
      const completionResponse = await request(app.getHttpServer())
        .post(`/cours/child/${childId}/complete/communication`)
        .expect(201);

      expect(completionResponse.body).toMatchObject({
        childId: childId,
        matiere: 'communication',
        currentStep: 'synthese',
        progressPercent: 100,
      });
      expect(completionResponse.body.completedAt).toBeDefined();

      // V√©rifier les stats finales
      const statsResponse = await request(app.getHttpServer())
        .get(`/cours/child/${childId}/stats`)
        .expect(200);

      console.log('üèÜ COURS TERMIN√â AVEC SUCC√àS !');
      console.log('üìú Certificat: Ma√Ætrise de la communication par pictogrammes');
      console.log(`‚è∞ Temps total: ~10 minutes`);
      console.log(`üìä Progression finale: ${completionResponse.body.progressPercent}%`);
      console.log(`üìÖ Date de completion: ${new Date(completionResponse.body.completedAt).toLocaleString()}`);
      console.log(`üìà Cours disponibles: ${statsResponse.body.totalCours}`);
      
      // Message de f√©licitation
      console.log(`\nüéä F√©licitations ${childName} !`);
      console.log('Tu sais maintenant communiquer avec les pictogrammes !');
      console.log('üí™ Tu peux exprimer tes besoins et √©motions facilement !');
      console.log('üåü Tu as d√©velopp√© ton autonomie et tes comp√©tences sociales !');
    });

    it('üìä V√©rification finale: Le parcours communication est enregistr√©', async () => {
      console.log(`\nüìä V√©rification du parcours communication de ${childName}...`);
      
      const finalProgress = await request(app.getHttpServer())
        .get(`/cours/child/${childId}/progress/communication`)
        .expect(200);

      const finalStats = await request(app.getHttpServer())
        .get(`/cours/child/${childId}/stats`)
        .expect(200);

      expect(finalProgress.body.progressPercent).toBe(100);
      expect(finalProgress.body.completedAt).toBeDefined();
      expect(finalStats.body.totalCours).toBe(3);
      
      console.log('‚úÖ Progression communication sauvegard√©e');
      console.log('‚úÖ Comp√©tences pictogrammes valid√©es');
      console.log('‚úÖ Certificat communication g√©n√©r√©');
      console.log('\nüí¨ Mission accomplie ! Noah communique avec les pictogrammes ! üí¨');
    });
  });
}); 